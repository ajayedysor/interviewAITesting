"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/meeting/[meetingId]/page",{

/***/ "(app-pages-browser)/./hooks/use-face-detection.ts":
/*!*************************************!*\
  !*** ./hooks/use-face-detection.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFaceDetection: () => (/* binding */ useFaceDetection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mediapipe/tasks-vision */ \"(app-pages-browser)/./node_modules/@mediapipe/tasks-vision/vision_bundle.mjs\");\n/* __next_internal_client_entry_do_not_use__ useFaceDetection auto */ \n\nfunction useFaceDetection(videoRef) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { onViolation, noFaceThreshold = 3, lookAwayThreshold = 4 } = options;\n    const [metrics, setMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        faceDetected: false,\n        faceCount: 0,\n        eyeContact: \"lost\",\n        headPosition: \"center\",\n        isMouthOpen: false\n    });\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const detectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const requestRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        noFaceStart: null,\n        lookAwayStart: null,\n        lastViolation: 0\n    });\n    // Initialize MediaPipe Face Detector\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useFaceDetection.useEffect\": ()=>{\n            async function initDetector() {\n                try {\n                    const vision = await _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_1__.FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm\");\n                    const detector = await _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_1__.FaceDetector.createFromOptions(vision, {\n                        baseOptions: {\n                            modelAssetPath: \"https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite\",\n                            delegate: \"GPU\"\n                        },\n                        runningMode: \"VIDEO\"\n                    });\n                    detectorRef.current = detector;\n                    setIsLoading(false);\n                } catch (err) {\n                    console.error(\"Failed to initialize MediaPipe Face Detector:\", err);\n                    setError(\"Failed to load face detection models.\");\n                    setIsLoading(false);\n                }\n            }\n            initDetector();\n            return ({\n                \"useFaceDetection.useEffect\": ()=>{\n                    var _detectorRef_current;\n                    if (requestRef.current) cancelAnimationFrame(requestRef.current);\n                    (_detectorRef_current = detectorRef.current) === null || _detectorRef_current === void 0 ? void 0 : _detectorRef_current.close();\n                }\n            })[\"useFaceDetection.useEffect\"];\n        }\n    }[\"useFaceDetection.useEffect\"], []);\n    const detect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useFaceDetection.useCallback[detect]\": ()=>{\n            if (!detectorRef.current || !videoRef.current || videoRef.current.readyState < 2) {\n                requestRef.current = requestAnimationFrame(detect);\n                return;\n            }\n            const timestamp = performance.now();\n            const result = detectorRef.current.detectForVideo(videoRef.current, timestamp);\n            processResults(result);\n            requestRef.current = requestAnimationFrame(detect);\n        }\n    }[\"useFaceDetection.useCallback[detect]\"], []);\n    const processResults = (result)=>{\n        const faces = result.detections;\n        const faceCount = faces.length;\n        const faceDetected = faceCount > 0;\n        const now = Date.now();\n        let newMetrics = {\n            faceDetected,\n            faceCount,\n            eyeContact: \"lost\",\n            headPosition: \"center\",\n            isMouthOpen: false\n        };\n        if (faceDetected) {\n            const face = faces[0];\n            const keypoints = face.keypoints;\n            // keypoints: 0=left eye, 1=right eye, 2=nose, 3=mouth, 4=left ear, 5=right ear\n            if (keypoints && keypoints.length >= 6) {\n                const leftEye = keypoints[0];\n                const rightEye = keypoints[1];\n                const nose = keypoints[2];\n                const leftEar = keypoints[4];\n                const rightEar = keypoints[5];\n                // Horizontal position (Yaw heuristic)\n                const leftDist = Math.abs(nose.x - leftEar.x);\n                const rightDist = Math.abs(nose.x - rightEar.x);\n                const ratio = leftDist / rightDist;\n                if (ratio > 2.5) newMetrics.headPosition = \"right\";\n                else if (ratio < 0.4) newMetrics.headPosition = \"left\";\n                else newMetrics.headPosition = \"center\";\n                // Vertical position (Pitch heuristic)\n                const eyeY = (leftEye.y + rightEye.y) / 2;\n                const noseY = nose.y;\n                if (noseY - eyeY < 0.02) newMetrics.headPosition = \"up\";\n                // Simple heuristic for down is harder without baseline, skipping for now\n                // Eye contact (Simplified: if looking too far left/right/up)\n                if (newMetrics.headPosition !== \"center\") {\n                    newMetrics.eyeContact = \"poor\";\n                    if (!lastStateRef.current.lookAwayStart) {\n                        lastStateRef.current.lookAwayStart = now;\n                    } else if (now - lastStateRef.current.lookAwayStart > lookAwayThreshold * 1000) {\n                        if (now - lastStateRef.current.lastViolation > 15000) {\n                            onViolation === null || onViolation === void 0 ? void 0 : onViolation({\n                                type: \"eye_contact\",\n                                message: \"I've noticed you're looking away from the screen. Please try to maintain eye contact with me.\",\n                                timestamp: now\n                            });\n                            lastStateRef.current.lastViolation = now;\n                        }\n                    }\n                } else {\n                    newMetrics.eyeContact = \"good\";\n                    lastStateRef.current.lookAwayStart = null;\n                }\n            }\n            // Reset no-face timer\n            lastStateRef.current.noFaceStart = null;\n            // Violation Check: Multiple People\n            if (faceCount > 1 && now - lastStateRef.current.lastViolation > 10000) {\n                onViolation === null || onViolation === void 0 ? void 0 : onViolation({\n                    type: \"multiple_people\",\n                    message: \"I've noticed another person in your frame. Please ensure you are alone during this interview.\",\n                    timestamp: now\n                });\n                lastStateRef.current.lastViolation = now;\n            }\n        } else {\n            // Person not detected\n            newMetrics.eyeContact = \"lost\";\n            if (!lastStateRef.current.noFaceStart) {\n                lastStateRef.current.noFaceStart = now;\n            } else if (now - lastStateRef.current.noFaceStart > noFaceThreshold * 1000) {\n                if (now - lastStateRef.current.lastViolation > 15000) {\n                    onViolation === null || onViolation === void 0 ? void 0 : onViolation({\n                        type: \"no_face\",\n                        message: \"I cannot see you. Please make sure your face is clearly visible to the camera.\",\n                        timestamp: now\n                    });\n                    lastStateRef.current.lastViolation = now;\n                }\n            }\n        }\n        setMetrics(newMetrics);\n    };\n    const startDetection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useFaceDetection.useCallback[startDetection]\": ()=>{\n            detect();\n        }\n    }[\"useFaceDetection.useCallback[startDetection]\"], [\n        detect\n    ]);\n    const stopDetection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useFaceDetection.useCallback[stopDetection]\": ()=>{\n            if (requestRef.current) cancelAnimationFrame(requestRef.current);\n        }\n    }[\"useFaceDetection.useCallback[stopDetection]\"], []);\n    return {\n        metrics,\n        isLoading,\n        error,\n        startDetection,\n        stopDetection\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1mYWNlLWRldGVjdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O3NFQUVpRTtBQUMyQjtBQXNCckYsU0FBU00saUJBQ2RDLFFBQWtEO1FBQ2xEQyxVQUFBQSxpRUFBbUMsQ0FBQztJQUVwQyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsa0JBQWtCLENBQUMsRUFBRUMsb0JBQW9CLENBQUMsRUFBRSxHQUFHSDtJQUVwRSxNQUFNLENBQUNJLFNBQVNDLFdBQVcsR0FBR1gsK0NBQVFBLENBQWM7UUFDbERZLGNBQWM7UUFDZEMsV0FBVztRQUNYQyxZQUFZO1FBQ1pDLGNBQWM7UUFDZEMsYUFBYTtJQUNmO0lBRUEsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNtQixPQUFPQyxTQUFTLEdBQUdwQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTXFCLGNBQWN0Qiw2Q0FBTUEsQ0FBc0I7SUFDaEQsTUFBTXVCLGFBQWF2Qiw2Q0FBTUEsQ0FBZ0I7SUFDekMsTUFBTXdCLGVBQWV4Qiw2Q0FBTUEsQ0FBQztRQUMxQnlCLGFBQWE7UUFDYkMsZUFBZTtRQUNmQyxlQUFlO0lBQ2pCO0lBRUEscUNBQXFDO0lBQ3JDNUIsZ0RBQVNBO3NDQUFDO1lBQ1IsZUFBZTZCO2dCQUNiLElBQUk7b0JBQ0YsTUFBTUMsU0FBUyxNQUFNekIsb0VBQWVBLENBQUMwQixjQUFjLENBQ2pEO29CQUVGLE1BQU1DLFdBQVcsTUFBTTVCLGlFQUFZQSxDQUFDNkIsaUJBQWlCLENBQUNILFFBQVE7d0JBQzVESSxhQUFhOzRCQUNYQyxnQkFBaUI7NEJBQ2pCQyxVQUFVO3dCQUNaO3dCQUNBQyxhQUFhO29CQUNmO29CQUNBZCxZQUFZZSxPQUFPLEdBQUdOO29CQUN0QlosYUFBYTtnQkFDZixFQUFFLE9BQU9tQixLQUFLO29CQUNaQyxRQUFRbkIsS0FBSyxDQUFDLGlEQUFpRGtCO29CQUMvRGpCLFNBQVM7b0JBQ1RGLGFBQWE7Z0JBQ2Y7WUFDRjtZQUNBUztZQUVBOzhDQUFPO3dCQUVMTjtvQkFEQSxJQUFJQyxXQUFXYyxPQUFPLEVBQUVHLHFCQUFxQmpCLFdBQVdjLE9BQU87cUJBQy9EZix1QkFBQUEsWUFBWWUsT0FBTyxjQUFuQmYsMkNBQUFBLHFCQUFxQm1CLEtBQUs7Z0JBQzVCOztRQUNGO3FDQUFHLEVBQUU7SUFFTCxNQUFNQyxTQUFTeEMsa0RBQVdBO2dEQUFDO1lBQ3pCLElBQUksQ0FBQ29CLFlBQVllLE9BQU8sSUFBSSxDQUFDL0IsU0FBUytCLE9BQU8sSUFBSS9CLFNBQVMrQixPQUFPLENBQUNNLFVBQVUsR0FBRyxHQUFHO2dCQUNoRnBCLFdBQVdjLE9BQU8sR0FBR08sc0JBQXNCRjtnQkFDM0M7WUFDRjtZQUVBLE1BQU1HLFlBQVlDLFlBQVlDLEdBQUc7WUFDakMsTUFBTUMsU0FBUzFCLFlBQVllLE9BQU8sQ0FBQ1ksY0FBYyxDQUFDM0MsU0FBUytCLE9BQU8sRUFBRVE7WUFDcEVLLGVBQWVGO1lBRWZ6QixXQUFXYyxPQUFPLEdBQUdPLHNCQUFzQkY7UUFDN0M7K0NBQUcsRUFBRTtJQUVMLE1BQU1RLGlCQUFpQixDQUFDRjtRQUN0QixNQUFNRyxRQUFRSCxPQUFPSSxVQUFVO1FBQy9CLE1BQU10QyxZQUFZcUMsTUFBTUUsTUFBTTtRQUM5QixNQUFNeEMsZUFBZUMsWUFBWTtRQUNqQyxNQUFNaUMsTUFBTU8sS0FBS1AsR0FBRztRQUVwQixJQUFJUSxhQUEwQjtZQUM1QjFDO1lBQ0FDO1lBQ0FDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxhQUFhO1FBQ2Y7UUFFQSxJQUFJSixjQUFjO1lBQ2hCLE1BQU0yQyxPQUFPTCxLQUFLLENBQUMsRUFBRTtZQUNyQixNQUFNTSxZQUFZRCxLQUFLQyxTQUFTO1lBRWhDLCtFQUErRTtZQUMvRSxJQUFJQSxhQUFhQSxVQUFVSixNQUFNLElBQUksR0FBRztnQkFDdEMsTUFBTUssVUFBVUQsU0FBUyxDQUFDLEVBQUU7Z0JBQzVCLE1BQU1FLFdBQVdGLFNBQVMsQ0FBQyxFQUFFO2dCQUM3QixNQUFNRyxPQUFPSCxTQUFTLENBQUMsRUFBRTtnQkFDekIsTUFBTUksVUFBVUosU0FBUyxDQUFDLEVBQUU7Z0JBQzVCLE1BQU1LLFdBQVdMLFNBQVMsQ0FBQyxFQUFFO2dCQUU3QixzQ0FBc0M7Z0JBQ3RDLE1BQU1NLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQ0wsS0FBS00sQ0FBQyxHQUFHTCxRQUFRSyxDQUFDO2dCQUM1QyxNQUFNQyxZQUFZSCxLQUFLQyxHQUFHLENBQUNMLEtBQUtNLENBQUMsR0FBR0osU0FBU0ksQ0FBQztnQkFDOUMsTUFBTUUsUUFBUUwsV0FBV0k7Z0JBRXpCLElBQUlDLFFBQVEsS0FBS2IsV0FBV3ZDLFlBQVksR0FBRztxQkFDdEMsSUFBSW9ELFFBQVEsS0FBS2IsV0FBV3ZDLFlBQVksR0FBRztxQkFDM0N1QyxXQUFXdkMsWUFBWSxHQUFHO2dCQUUvQixzQ0FBc0M7Z0JBQ3RDLE1BQU1xRCxPQUFPLENBQUNYLFFBQVFZLENBQUMsR0FBR1gsU0FBU1csQ0FBQyxJQUFJO2dCQUN4QyxNQUFNQyxRQUFRWCxLQUFLVSxDQUFDO2dCQUNwQixJQUFJQyxRQUFRRixPQUFPLE1BQU1kLFdBQVd2QyxZQUFZLEdBQUc7Z0JBQ25ELHlFQUF5RTtnQkFFekUsNkRBQTZEO2dCQUM3RCxJQUFJdUMsV0FBV3ZDLFlBQVksS0FBSyxVQUFVO29CQUN0Q3VDLFdBQVd4QyxVQUFVLEdBQUc7b0JBQ3hCLElBQUksQ0FBQ1MsYUFBYWEsT0FBTyxDQUFDWCxhQUFhLEVBQUU7d0JBQ3JDRixhQUFhYSxPQUFPLENBQUNYLGFBQWEsR0FBR3FCO29CQUN6QyxPQUFPLElBQUlBLE1BQU12QixhQUFhYSxPQUFPLENBQUNYLGFBQWEsR0FBR2hCLG9CQUFvQixNQUFNO3dCQUM1RSxJQUFJcUMsTUFBTXZCLGFBQWFhLE9BQU8sQ0FBQ1YsYUFBYSxHQUFHLE9BQU87NEJBQ2xEbkIsd0JBQUFBLGtDQUFBQSxZQUFjO2dDQUNWZ0UsTUFBTTtnQ0FDTkMsU0FBUztnQ0FDVDVCLFdBQVdFOzRCQUNmOzRCQUNBdkIsYUFBYWEsT0FBTyxDQUFDVixhQUFhLEdBQUdvQjt3QkFDekM7b0JBQ0o7Z0JBQ0osT0FBTztvQkFDSFEsV0FBV3hDLFVBQVUsR0FBRztvQkFDeEJTLGFBQWFhLE9BQU8sQ0FBQ1gsYUFBYSxHQUFHO2dCQUN6QztZQUNGO1lBRUEsc0JBQXNCO1lBQ3RCRixhQUFhYSxPQUFPLENBQUNaLFdBQVcsR0FBRztZQUVuQyxtQ0FBbUM7WUFDbkMsSUFBSVgsWUFBWSxLQUFLaUMsTUFBTXZCLGFBQWFhLE9BQU8sQ0FBQ1YsYUFBYSxHQUFHLE9BQU87Z0JBQ25FbkIsd0JBQUFBLGtDQUFBQSxZQUFjO29CQUNWZ0UsTUFBTTtvQkFDTkMsU0FBUztvQkFDVDVCLFdBQVdFO2dCQUNmO2dCQUNBdkIsYUFBYWEsT0FBTyxDQUFDVixhQUFhLEdBQUdvQjtZQUN6QztRQUVGLE9BQU87WUFDSCxzQkFBc0I7WUFDdEJRLFdBQVd4QyxVQUFVLEdBQUc7WUFDeEIsSUFBSSxDQUFDUyxhQUFhYSxPQUFPLENBQUNaLFdBQVcsRUFBRTtnQkFDbkNELGFBQWFhLE9BQU8sQ0FBQ1osV0FBVyxHQUFHc0I7WUFDdkMsT0FBTyxJQUFJQSxNQUFNdkIsYUFBYWEsT0FBTyxDQUFDWixXQUFXLEdBQUdoQixrQkFBa0IsTUFBTTtnQkFDeEUsSUFBSXNDLE1BQU12QixhQUFhYSxPQUFPLENBQUNWLGFBQWEsR0FBRyxPQUFPO29CQUNsRG5CLHdCQUFBQSxrQ0FBQUEsWUFBYzt3QkFDVmdFLE1BQU07d0JBQ05DLFNBQVM7d0JBQ1Q1QixXQUFXRTtvQkFDZjtvQkFDQXZCLGFBQWFhLE9BQU8sQ0FBQ1YsYUFBYSxHQUFHb0I7Z0JBQ3pDO1lBQ0o7UUFDSjtRQUVBbkMsV0FBVzJDO0lBQ2I7SUFFQSxNQUFNbUIsaUJBQWlCeEUsa0RBQVdBO3dEQUFDO1lBQ2pDd0M7UUFDRjt1REFBRztRQUFDQTtLQUFPO0lBRVgsTUFBTWlDLGdCQUFnQnpFLGtEQUFXQTt1REFBQztZQUNoQyxJQUFJcUIsV0FBV2MsT0FBTyxFQUFFRyxxQkFBcUJqQixXQUFXYyxPQUFPO1FBQ2pFO3NEQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0wxQjtRQUNBTztRQUNBRTtRQUNBc0Q7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFqYXlcXE9uZURyaXZlXFxEb2N1bWVudHNcXEludGVydmlld19Db2RlXFxhaS1pbnRlcnZpZXctZWR5c29yLW1haW5cXGFpLWludGVydmlldy1lZHlzb3ItbWFpblxcc3R1ZGVudC1zaWRlXFxzdHVkZW50LXNpZGVcXGhvb2tzXFx1c2UtZmFjZS1kZXRlY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEZhY2VEZXRlY3RvciwgRmlsZXNldFJlc29sdmVyLCBGYWNlRGV0ZWN0b3JSZXN1bHQgfSBmcm9tIFwiQG1lZGlhcGlwZS90YXNrcy12aXNpb25cIjtcblxuZXhwb3J0IGludGVyZmFjZSBGYWNlTWV0cmljcyB7XG4gIGZhY2VEZXRlY3RlZDogYm9vbGVhbjtcbiAgZmFjZUNvdW50OiBudW1iZXI7XG4gIGV5ZUNvbnRhY3Q6IFwiZ29vZFwiIHwgXCJwb29yXCIgfCBcImxvc3RcIjtcbiAgaGVhZFBvc2l0aW9uOiBcImNlbnRlclwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIgfCBcInVwXCIgfCBcImRvd25cIjtcbiAgaXNNb3V0aE9wZW46IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlvbGF0aW9uIHtcbiAgdHlwZTogc3RyaW5nO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVXNlRmFjZURldGVjdGlvbk9wdGlvbnMge1xuICBvblZpb2xhdGlvbj86ICh2aW9sYXRpb246IFZpb2xhdGlvbikgPT4gdm9pZDtcbiAgbm9GYWNlVGhyZXNob2xkPzogbnVtYmVyOyAvLyBzZWNvbmRzXG4gIGxvb2tBd2F5VGhyZXNob2xkPzogbnVtYmVyOyAvLyBzZWNvbmRzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGYWNlRGV0ZWN0aW9uKFxuICB2aWRlb1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsPixcbiAgb3B0aW9uczogVXNlRmFjZURldGVjdGlvbk9wdGlvbnMgPSB7fVxuKSB7XG4gIGNvbnN0IHsgb25WaW9sYXRpb24sIG5vRmFjZVRocmVzaG9sZCA9IDMsIGxvb2tBd2F5VGhyZXNob2xkID0gNCB9ID0gb3B0aW9ucztcblxuICBjb25zdCBbbWV0cmljcywgc2V0TWV0cmljc10gPSB1c2VTdGF0ZTxGYWNlTWV0cmljcz4oe1xuICAgIGZhY2VEZXRlY3RlZDogZmFsc2UsXG4gICAgZmFjZUNvdW50OiAwLFxuICAgIGV5ZUNvbnRhY3Q6IFwibG9zdFwiLFxuICAgIGhlYWRQb3NpdGlvbjogXCJjZW50ZXJcIixcbiAgICBpc01vdXRoT3BlbjogZmFsc2UsXG4gIH0pO1xuXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBkZXRlY3RvclJlZiA9IHVzZVJlZjxGYWNlRGV0ZWN0b3IgfCBudWxsPihudWxsKTtcbiAgY29uc3QgcmVxdWVzdFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbGFzdFN0YXRlUmVmID0gdXNlUmVmKHtcbiAgICBub0ZhY2VTdGFydDogbnVsbCBhcyBudW1iZXIgfCBudWxsLFxuICAgIGxvb2tBd2F5U3RhcnQ6IG51bGwgYXMgbnVtYmVyIHwgbnVsbCxcbiAgICBsYXN0VmlvbGF0aW9uOiAwLFxuICB9KTtcblxuICAvLyBJbml0aWFsaXplIE1lZGlhUGlwZSBGYWNlIERldGVjdG9yXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gaW5pdERldGVjdG9yKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmlzaW9uID0gYXdhaXQgRmlsZXNldFJlc29sdmVyLmZvclZpc2lvblRhc2tzKFxuICAgICAgICAgIFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AbWVkaWFwaXBlL3Rhc2tzLXZpc2lvbkAwLjEwLjMvd2FzbVwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGRldGVjdG9yID0gYXdhaXQgRmFjZURldGVjdG9yLmNyZWF0ZUZyb21PcHRpb25zKHZpc2lvbiwge1xuICAgICAgICAgIGJhc2VPcHRpb25zOiB7XG4gICAgICAgICAgICBtb2RlbEFzc2V0UGF0aDogYGh0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9tZWRpYXBpcGUtbW9kZWxzL2ZhY2VfZGV0ZWN0b3IvYmxhemVfZmFjZV9zaG9ydF9yYW5nZS9mbG9hdDE2LzEvYmxhemVfZmFjZV9zaG9ydF9yYW5nZS50ZmxpdGVgLFxuICAgICAgICAgICAgZGVsZWdhdGU6IFwiR1BVXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBydW5uaW5nTW9kZTogXCJWSURFT1wiLFxuICAgICAgICB9KTtcbiAgICAgICAgZGV0ZWN0b3JSZWYuY3VycmVudCA9IGRldGVjdG9yO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBNZWRpYVBpcGUgRmFjZSBEZXRlY3RvcjpcIiwgZXJyKTtcbiAgICAgICAgc2V0RXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBmYWNlIGRldGVjdGlvbiBtb2RlbHMuXCIpO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbml0RGV0ZWN0b3IoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdFJlZi5jdXJyZW50KSBjYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0UmVmLmN1cnJlbnQpO1xuICAgICAgZGV0ZWN0b3JSZWYuY3VycmVudD8uY2xvc2UoKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZGV0ZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghZGV0ZWN0b3JSZWYuY3VycmVudCB8fCAhdmlkZW9SZWYuY3VycmVudCB8fCB2aWRlb1JlZi5jdXJyZW50LnJlYWR5U3RhdGUgPCAyKSB7XG4gICAgICByZXF1ZXN0UmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGV0ZWN0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCByZXN1bHQgPSBkZXRlY3RvclJlZi5jdXJyZW50LmRldGVjdEZvclZpZGVvKHZpZGVvUmVmLmN1cnJlbnQsIHRpbWVzdGFtcCk7XG4gICAgcHJvY2Vzc1Jlc3VsdHMocmVzdWx0KTtcblxuICAgIHJlcXVlc3RSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkZXRlY3QpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgcHJvY2Vzc1Jlc3VsdHMgPSAocmVzdWx0OiBGYWNlRGV0ZWN0b3JSZXN1bHQpID0+IHtcbiAgICBjb25zdCBmYWNlcyA9IHJlc3VsdC5kZXRlY3Rpb25zO1xuICAgIGNvbnN0IGZhY2VDb3VudCA9IGZhY2VzLmxlbmd0aDtcbiAgICBjb25zdCBmYWNlRGV0ZWN0ZWQgPSBmYWNlQ291bnQgPiAwO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBsZXQgbmV3TWV0cmljczogRmFjZU1ldHJpY3MgPSB7XG4gICAgICBmYWNlRGV0ZWN0ZWQsXG4gICAgICBmYWNlQ291bnQsXG4gICAgICBleWVDb250YWN0OiBcImxvc3RcIixcbiAgICAgIGhlYWRQb3NpdGlvbjogXCJjZW50ZXJcIixcbiAgICAgIGlzTW91dGhPcGVuOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgaWYgKGZhY2VEZXRlY3RlZCkge1xuICAgICAgY29uc3QgZmFjZSA9IGZhY2VzWzBdO1xuICAgICAgY29uc3Qga2V5cG9pbnRzID0gZmFjZS5rZXlwb2ludHM7XG4gICAgICBcbiAgICAgIC8vIGtleXBvaW50czogMD1sZWZ0IGV5ZSwgMT1yaWdodCBleWUsIDI9bm9zZSwgMz1tb3V0aCwgND1sZWZ0IGVhciwgNT1yaWdodCBlYXJcbiAgICAgIGlmIChrZXlwb2ludHMgJiYga2V5cG9pbnRzLmxlbmd0aCA+PSA2KSB7XG4gICAgICAgIGNvbnN0IGxlZnRFeWUgPSBrZXlwb2ludHNbMF07XG4gICAgICAgIGNvbnN0IHJpZ2h0RXllID0ga2V5cG9pbnRzWzFdO1xuICAgICAgICBjb25zdCBub3NlID0ga2V5cG9pbnRzWzJdO1xuICAgICAgICBjb25zdCBsZWZ0RWFyID0ga2V5cG9pbnRzWzRdO1xuICAgICAgICBjb25zdCByaWdodEVhciA9IGtleXBvaW50c1s1XTtcblxuICAgICAgICAvLyBIb3Jpem9udGFsIHBvc2l0aW9uIChZYXcgaGV1cmlzdGljKVxuICAgICAgICBjb25zdCBsZWZ0RGlzdCA9IE1hdGguYWJzKG5vc2UueCAtIGxlZnRFYXIueCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0RGlzdCA9IE1hdGguYWJzKG5vc2UueCAtIHJpZ2h0RWFyLngpO1xuICAgICAgICBjb25zdCByYXRpbyA9IGxlZnREaXN0IC8gcmlnaHREaXN0O1xuXG4gICAgICAgIGlmIChyYXRpbyA+IDIuNSkgbmV3TWV0cmljcy5oZWFkUG9zaXRpb24gPSBcInJpZ2h0XCI7XG4gICAgICAgIGVsc2UgaWYgKHJhdGlvIDwgMC40KSBuZXdNZXRyaWNzLmhlYWRQb3NpdGlvbiA9IFwibGVmdFwiO1xuICAgICAgICBlbHNlIG5ld01ldHJpY3MuaGVhZFBvc2l0aW9uID0gXCJjZW50ZXJcIjtcblxuICAgICAgICAvLyBWZXJ0aWNhbCBwb3NpdGlvbiAoUGl0Y2ggaGV1cmlzdGljKVxuICAgICAgICBjb25zdCBleWVZID0gKGxlZnRFeWUueSArIHJpZ2h0RXllLnkpIC8gMjtcbiAgICAgICAgY29uc3Qgbm9zZVkgPSBub3NlLnk7XG4gICAgICAgIGlmIChub3NlWSAtIGV5ZVkgPCAwLjAyKSBuZXdNZXRyaWNzLmhlYWRQb3NpdGlvbiA9IFwidXBcIjtcbiAgICAgICAgLy8gU2ltcGxlIGhldXJpc3RpYyBmb3IgZG93biBpcyBoYXJkZXIgd2l0aG91dCBiYXNlbGluZSwgc2tpcHBpbmcgZm9yIG5vd1xuXG4gICAgICAgIC8vIEV5ZSBjb250YWN0IChTaW1wbGlmaWVkOiBpZiBsb29raW5nIHRvbyBmYXIgbGVmdC9yaWdodC91cClcbiAgICAgICAgaWYgKG5ld01ldHJpY3MuaGVhZFBvc2l0aW9uICE9PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICBuZXdNZXRyaWNzLmV5ZUNvbnRhY3QgPSBcInBvb3JcIjtcbiAgICAgICAgICAgIGlmICghbGFzdFN0YXRlUmVmLmN1cnJlbnQubG9va0F3YXlTdGFydCkge1xuICAgICAgICAgICAgICAgIGxhc3RTdGF0ZVJlZi5jdXJyZW50Lmxvb2tBd2F5U3RhcnQgPSBub3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vdyAtIGxhc3RTdGF0ZVJlZi5jdXJyZW50Lmxvb2tBd2F5U3RhcnQgPiBsb29rQXdheVRocmVzaG9sZCAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICBpZiAobm93IC0gbGFzdFN0YXRlUmVmLmN1cnJlbnQubGFzdFZpb2xhdGlvbiA+IDE1MDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlvbGF0aW9uPy4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJleWVfY29udGFjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJJ3ZlIG5vdGljZWQgeW91J3JlIGxvb2tpbmcgYXdheSBmcm9tIHRoZSBzY3JlZW4uIFBsZWFzZSB0cnkgdG8gbWFpbnRhaW4gZXllIGNvbnRhY3Qgd2l0aCBtZS5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbm93XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhdGVSZWYuY3VycmVudC5sYXN0VmlvbGF0aW9uID0gbm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01ldHJpY3MuZXllQ29udGFjdCA9IFwiZ29vZFwiO1xuICAgICAgICAgICAgbGFzdFN0YXRlUmVmLmN1cnJlbnQubG9va0F3YXlTdGFydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgbm8tZmFjZSB0aW1lclxuICAgICAgbGFzdFN0YXRlUmVmLmN1cnJlbnQubm9GYWNlU3RhcnQgPSBudWxsO1xuICAgICAgXG4gICAgICAvLyBWaW9sYXRpb24gQ2hlY2s6IE11bHRpcGxlIFBlb3BsZVxuICAgICAgaWYgKGZhY2VDb3VudCA+IDEgJiYgbm93IC0gbGFzdFN0YXRlUmVmLmN1cnJlbnQubGFzdFZpb2xhdGlvbiA+IDEwMDAwKSB7XG4gICAgICAgICAgb25WaW9sYXRpb24/Lih7XG4gICAgICAgICAgICAgIHR5cGU6IFwibXVsdGlwbGVfcGVvcGxlXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSSd2ZSBub3RpY2VkIGFub3RoZXIgcGVyc29uIGluIHlvdXIgZnJhbWUuIFBsZWFzZSBlbnN1cmUgeW91IGFyZSBhbG9uZSBkdXJpbmcgdGhpcyBpbnRlcnZpZXcuXCIsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbm93XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdFN0YXRlUmVmLmN1cnJlbnQubGFzdFZpb2xhdGlvbiA9IG5vdztcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBlcnNvbiBub3QgZGV0ZWN0ZWRcbiAgICAgICAgbmV3TWV0cmljcy5leWVDb250YWN0ID0gXCJsb3N0XCI7XG4gICAgICAgIGlmICghbGFzdFN0YXRlUmVmLmN1cnJlbnQubm9GYWNlU3RhcnQpIHtcbiAgICAgICAgICAgIGxhc3RTdGF0ZVJlZi5jdXJyZW50Lm5vRmFjZVN0YXJ0ID0gbm93O1xuICAgICAgICB9IGVsc2UgaWYgKG5vdyAtIGxhc3RTdGF0ZVJlZi5jdXJyZW50Lm5vRmFjZVN0YXJ0ID4gbm9GYWNlVGhyZXNob2xkICogMTAwMCkge1xuICAgICAgICAgICAgaWYgKG5vdyAtIGxhc3RTdGF0ZVJlZi5jdXJyZW50Lmxhc3RWaW9sYXRpb24gPiAxNTAwMCkge1xuICAgICAgICAgICAgICAgIG9uVmlvbGF0aW9uPy4oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5vX2ZhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJIGNhbm5vdCBzZWUgeW91LiBQbGVhc2UgbWFrZSBzdXJlIHlvdXIgZmFjZSBpcyBjbGVhcmx5IHZpc2libGUgdG8gdGhlIGNhbWVyYS5cIixcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBub3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsYXN0U3RhdGVSZWYuY3VycmVudC5sYXN0VmlvbGF0aW9uID0gbm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TWV0cmljcyhuZXdNZXRyaWNzKTtcbiAgfTtcblxuICBjb25zdCBzdGFydERldGVjdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBkZXRlY3QoKTtcbiAgfSwgW2RldGVjdF0pO1xuXG4gIGNvbnN0IHN0b3BEZXRlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHJlcXVlc3RSZWYuY3VycmVudCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdFJlZi5jdXJyZW50KTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgbWV0cmljcyxcbiAgICBpc0xvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgc3RhcnREZXRlY3Rpb24sXG4gICAgc3RvcERldGVjdGlvbixcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiRmFjZURldGVjdG9yIiwiRmlsZXNldFJlc29sdmVyIiwidXNlRmFjZURldGVjdGlvbiIsInZpZGVvUmVmIiwib3B0aW9ucyIsIm9uVmlvbGF0aW9uIiwibm9GYWNlVGhyZXNob2xkIiwibG9va0F3YXlUaHJlc2hvbGQiLCJtZXRyaWNzIiwic2V0TWV0cmljcyIsImZhY2VEZXRlY3RlZCIsImZhY2VDb3VudCIsImV5ZUNvbnRhY3QiLCJoZWFkUG9zaXRpb24iLCJpc01vdXRoT3BlbiIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJkZXRlY3RvclJlZiIsInJlcXVlc3RSZWYiLCJsYXN0U3RhdGVSZWYiLCJub0ZhY2VTdGFydCIsImxvb2tBd2F5U3RhcnQiLCJsYXN0VmlvbGF0aW9uIiwiaW5pdERldGVjdG9yIiwidmlzaW9uIiwiZm9yVmlzaW9uVGFza3MiLCJkZXRlY3RvciIsImNyZWF0ZUZyb21PcHRpb25zIiwiYmFzZU9wdGlvbnMiLCJtb2RlbEFzc2V0UGF0aCIsImRlbGVnYXRlIiwicnVubmluZ01vZGUiLCJjdXJyZW50IiwiZXJyIiwiY29uc29sZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2xvc2UiLCJkZXRlY3QiLCJyZWFkeVN0YXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGltZXN0YW1wIiwicGVyZm9ybWFuY2UiLCJub3ciLCJyZXN1bHQiLCJkZXRlY3RGb3JWaWRlbyIsInByb2Nlc3NSZXN1bHRzIiwiZmFjZXMiLCJkZXRlY3Rpb25zIiwibGVuZ3RoIiwiRGF0ZSIsIm5ld01ldHJpY3MiLCJmYWNlIiwia2V5cG9pbnRzIiwibGVmdEV5ZSIsInJpZ2h0RXllIiwibm9zZSIsImxlZnRFYXIiLCJyaWdodEVhciIsImxlZnREaXN0IiwiTWF0aCIsImFicyIsIngiLCJyaWdodERpc3QiLCJyYXRpbyIsImV5ZVkiLCJ5Iiwibm9zZVkiLCJ0eXBlIiwibWVzc2FnZSIsInN0YXJ0RGV0ZWN0aW9uIiwic3RvcERldGVjdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-face-detection.ts\n"));

/***/ })

});